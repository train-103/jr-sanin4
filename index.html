<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>JR山陰線列車走行位置(米子～益田)</title>

<style>
  body {
    background-color: #5A9FE0;
    margin: 0;
    font-family: monospace;
    overflow: hidden;
  }

  #time {
    position: fixed;
    top: 8px;
    left: 8px;
    color: white;
    font-size: 14px;
    z-index: 10;
  }

  #scroll-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-behavior: smooth;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
  }
</style>
</head>

<body>
<div id="time"></div>

<div id="scroll-container">
  <canvas id="bg"></canvas>
  <canvas id="panel"></canvas>
</div>

<script>
let lastTrains = [];
let fetching = false;

// ===============================
// 駅データ
// ===============================
const stations = [
  {code: "0029", name: "米子", x: 450},
  {code: "0031", name: "安来", x: 1050},
  {code: "0032", name: "荒島", x: 1650},
  {code: "0033", name: "揖屋", x: 2250},
  {code: "0034", name: "東松江", x: 2850},
  {code: "0035", name: "松江", x: 3450},
  {code: "0036", name: "乃木", x: 4050},
  {code: "0037", name: "玉造温泉", x: 4650},
  {code: "0038", name: "来待", x: 5250},
  {code: "0039", name: "宍道", x: 5850},
  {code: "0040", name: "荘原", x: 6450},
  {code: "0041", name: "直江", x: 7050},
  {code: "0042", name: "出雲市", x: 7650},
  {code: "0043", name: "西出雲", x: 8250},
  {code: "0044", name: "出雲神西", x: 8850},
  {code: "0045", name: "江南", x: 9450},
  {code: "0046", name: "小田", x: 10050},
  {code: "0047", name: "田儀", x: 10650},
  {code: "0048", name: "羽根", x: 11250},
  {code: "0049", name: "久手", x: 11850},
  {code: "0050", name: "大田市", x: 12450},
  {code: "0051", name: "静間", x: 13050},
  {code: "0052", name: "五十猛", x: 13650},
  {code: "0053", name: "仁万", x: 14250},
  {code: "0054", name: "馬路", x: 14850},
  {code: "0055", name: "湯里", x: 15450},
  {code: "0056", name: "温泉津", x: 16050},
  {code: "0057", name: "石見福光", x: 16650},
  {code: "0058", name: "黒松", x: 17250},
  {code: "0059", name: "浅利", x: 17850},
  {code: "0060", name: "江津", x: 18450},
　{code: "0061", name: "都野津", x: 19050},
　{code: "0062", name: "敬川", x: 19650},
　{code: "0063", name: "波子", x: 20250},
　{code: "0064", name: "久代", x: 20850},
　{code: "0065", name: "下府", x: 21450},
　{code: "0066", name: "浜田", x: 22050},
　{code: "0067", name: "西浜田", x: 22650},
　{code: "0068", name: "周布", x: 23250},
　{code: "0069", name: "折居", x: 23850},
　{code: "0070", name: "三保三隅", x: 24450},
　{code: "0071", name: "岡見", x: 25050},
　{code: "0072", name: "鎌手", x: 25650},
　{code: "0073", name: "石見津田", x: 26250},
　{code: "0074", name: "益田", x: 26850},
];

const TRACK_MARGIN = 500;

// ★ 複線仕様（旧 up2 / down1）
const TRACK_Y = {
  up: 240,
  down: 420
};

const bg = document.getElementById("bg");
const bgCtx = bg.getContext("2d");

const canvas = document.getElementById("panel");
const ctx = canvas.getContext("2d");

const trackStartX = Math.min(...stations.map(s => s.x)) - TRACK_MARGIN;
const trackEndX   = Math.max(...stations.map(s => s.x)) + TRACK_MARGIN;

bg.width = canvas.width = trackEndX;
bg.height = canvas.height = 800;

// ===============================
// 背景描画
// ===============================
function drawTrack(c) {
  c.strokeStyle = "white";
  c.lineWidth = 2;

  Object.values(TRACK_Y).forEach(y => {
    c.beginPath();
    c.moveTo(trackStartX, y);
    c.lineTo(trackEndX, y);
    c.stroke();
  });
}

function drawStations(c) {
  c.font = "14px monospace";

  stations.forEach(st => {
    c.fillStyle = "white";
    c.fillRect(st.x - 2, TRACK_Y.up - 2, 4, 4);
    c.fillRect(st.x - 2, TRACK_Y.down - 2, 4, 4);

    drawStationLabel(st, 80, true, c);
    drawStationLabel(st, 620, false, c);
  });
}

function drawBackground() {
  bgCtx.clearRect(0, 0, bg.width, bg.height);
  drawTrack(bgCtx);
  drawStations(bgCtx);
}

const stationHitAreas = [];

function drawStationLabel(st, y, clickable, c) {
  const text = st.name;
  const w = c.measureText(text).width + 14;
  const h = 22;
  const x = st.x - w / 2;

  c.fillStyle = "white";
  c.fillRect(x, y - h / 2, w, h);
  c.strokeStyle = "#333";
  c.strokeRect(x, y - h / 2, w, h);

  c.fillStyle = "black";
  c.textAlign = "center";
  c.textBaseline = "middle";
  c.fillText(text, st.x, y);

  if (clickable) {
    stationHitAreas.push({ x, y: y - h / 2, w, h, cx: st.x });
  }
}
// ★ スクロール位置を保存（手動更新対策）
const scrollContainer = document.getElementById("scroll-container");

scrollContainer.addEventListener("scroll", () => {
  localStorage.setItem("scrollLeft", scrollContainer.scrollLeft);
});


// ===============================
// データ取得
// ===============================


async function fetchTrainData() {
  if (fetching) return lastTrains;
  fetching = true;

  try {
    const res = await fetch(
      "https://jrsanyo1.hayato-110802.workers.dev/",
      { cache: "no-store" }
    );
    const data = await res.json();
    lastTrains = data.trains || lastTrains;
  } catch {
    console.warn("fetch失敗：前回データ使用");
  } finally {
    fetching = false;
  }
  return lastTrains;
}

// ===============================
// 線路判定（複線・方向のみ）
// ===============================
function getLastDigit(train) {
  const m = String(train.no || "").match(/(\d)(?!.*\d)/);
  return m ? Number(m[1]) : null;
}
  
// ===============================
// 普通列車判定
// ===============================
function isLocalTrain(train) {
  const type = train.displayType || "";
  return type.includes("普通");
}
  
function getTrackKey(train) {
  const last = getLastDigit(train);
  if (last === null) return "up";
  return (last % 2 === 1) ? "up" : "down";
}
// ===============================
// 停滞管理（localStorage）
// ===============================
const stayMap = JSON.parse(localStorage.getItem("stayMap") || "{}");
const crossMap = JSON.parse(localStorage.getItem("crossMap") || "{}");

const redBandMap = JSON.parse(
  localStorage.getItem("redBandMap") || "{}"
);

function updateStay(trainKey, x, isStation) {
  const now = Date.now();
  const s = stayMap[trainKey] || { x, t: now, station: isStation };
  
  if (Math.abs(s.x - x) < 5 && s.station === isStation) {
    // 継続
  } else {
    s.x = x;
    s.t = now;
    s.station = isStation;
  }

  stayMap[trainKey] = s;
  localStorage.setItem("stayMap", JSON.stringify(stayMap));
  return now - s.t;
}


// ===============================
// 列車描画
// ===============================
function drawTrains(trains) {
  const used = {};
  ctx.font = "12px monospace";

  trains.forEach(train => {
    const [from, toRaw] = train.pos.split("_");
      // ★ 停車中判定（今回の修正ポイント）
const isStationary = (toRaw === "####");
// ★ 描画用の to（駅間計算用）
const to = isStationary ? from : toRaw;

    const s1 = stations.find(s => s.code === from);
    const s2 = stations.find(s => s.code === to);
    if (!s1 || !s2) return;

    const trackKey = getTrackKey(train);
    const baseY = TRACK_Y[trackKey];

    const i1 = stations.indexOf(s1);
    const i2 = stations.indexOf(s2);

    let ratio = 0;
    if (i1 !== i2) {
      const num = parseInt(train.no.match(/\d+/)?.[0] || 0, 10);
      ratio = (num % 2 === 0) ? 1/3 : 2/3;
    }

    const x = s1.x + (s2.x - s1.x) * ratio;

    const sectionKey = `${Math.min(i1,i2)}-${Math.max(i1,i2)}`;
    const slot = `${trackKey}_${sectionKey}`;

    const y = baseY + (used[slot] || 0) * 28;
    used[slot] = (used[slot] || 0) + 1;

    const type = train.displayType || "";
    let bg = "#FFFF66";
    if (type.includes("特急")) bg = "#9A4A4A";
    else if (type.includes("新快速")) bg = "#3399FF";
    else if (type.includes("快速")) bg = "#FFA500";
    else if (type.includes("普通")) bg = "#6EDC3A";

    const noColor =
      (type.includes("特急") || type.includes("新快速")) ? "white" : "black";

    const delay = train.delayMinutes || 0;
    const delayText = delay > 0 ? String(delay) : "";

    const noText = train.no || "";


// ★ 行き先＋両数（⑧など）を合成
const destText = train.dest || ""; // ← ここを修正

const infoText = ` ${type} ${destText}`;
    const noW = ctx.measureText(noText).width + 10;
    const infoW = ctx.measureText(infoText).width + 10;
    const delayW = delayText ? ctx.measureText(delayText).width + 8 : 0;
    const h = 22;
    const totalW = noW + infoW + delayW;
    const leftX = x - totalW / 2;

    const trainKey = train.no + "_" + train.pos;
const stayMs = updateStay(trainKey, x, isStationary);
// ★ 追加：駅中心からの距離判定（複合判定用）
const stationX = s1.x;
const distFromStation = Math.abs(x - stationX);
const STATION_STOP_RADIUS = 6; // px
const isNearStationCenter = distFromStation <= STATION_STOP_RADIUS;
    
if (stayMs >= 600000) {
  crossMap[trainKey] = true;
  localStorage.setItem("crossMap", JSON.stringify(crossMap));
}

    // 赤帯関連
const isLocal = isLocalTrain(train);
let showRedBand = false;

// ===============================
// 普通：駅中心に停車していれば即赤帯
// ===============================
if (isLocal && isStationary && isNearStationCenter) {
  showRedBand = true;
}

// ===============================
// 普通以外：交互45秒判定（駅中心限定）
// ===============================
if (!isLocal && isStationary && isNearStationCenter) {
  const r = redBandMap[trainKey] || {
    phase: "record",
    baseX: x
  };

  if (r.phase === "record") {
    // 基準位置を記録するだけ
    r.baseX = x;
    r.phase = "check";
  } else {
  // check フェーズ
  if (Math.abs(r.baseX - x) < 5) {
    showRedBand = true;

    // ★ 赤帯を出した場合は phase を維持
    // 次の更新まで保持する
  } else {
    // 動いていたら記録フェーズへ戻す
    r.phase = "record";
  }
}

  redBandMap[trainKey] = r;
  localStorage.setItem("redBandMap", JSON.stringify(redBandMap));
}

// ===============================
// 赤帯描画
// ===============================
if (showRedBand) {
  ctx.fillStyle = "red";
  ctx.fillRect(leftX - 6, y - h/2, 6, h);
  ctx.fillRect(leftX + totalW, y - h/2, 6, h);
}

     // ×印：10分以上不動（赤丸＋黒枠＋白×）
if (crossMap[trainKey]) {
  ctx.save();  // ← これが重要
  
  const r = 8; // 丸の半径
  const cx = leftX - 20; // 列車枠から十分離す
  const cy = y;

  // 赤丸（塗り）
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = "red";
  ctx.fill();

  // ×印（太字）
  ctx.fillStyle = "white";
  ctx.font = "bold 15px monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("×", cx, cy);

  ctx.restore(); // ← 状態を完全に戻す
}

    ctx.fillStyle = "white";
    ctx.fillRect(leftX, y - h/2, totalW, h);

    ctx.fillStyle = bg;
    ctx.fillRect(leftX, y - h/2, noW, h);

    ctx.fillStyle = noColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(noText, leftX + noW/2, y);

    ctx.fillStyle = "black";
    ctx.fillText(infoText, leftX + noW + infoW/2, y);

    if (delayText) {
      ctx.fillStyle = "red";
      ctx.fillText(delayText, leftX + noW + infoW + delayW/2, y);
    }
  });
}

// ===============================
async function update() {
  // ★ 前景（列車）のみクリア
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ★ 駅クリック領域だけは毎回再登録
  stationHitAreas.length = 0;

  // ★ 背景は描かない（drawBackground() は呼ばない）

  // ★ 前回データで即描画（チラつき防止）
  // ★ 前回データがある場合のみ描画
if (lastTrains.length > 0) {
  drawTrains(lastTrains);
}

  // ★ 最新データ取得
  const trains = await fetchTrainData();

  // ★ 上書き描画
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawTrains(trains);

  document.getElementById("time").textContent =
    "更新: " + new Date().toLocaleTimeString();
}

drawBackground();
  // ★ 保存されているスクロール位置を復元
const savedScroll = localStorage.getItem("scrollLeft");
if (savedScroll !== null) {
  document.getElementById("scroll-container").scrollLeft = Number(savedScroll);
}
update();
setInterval(update, 45000);
</script>
</body>
</html>